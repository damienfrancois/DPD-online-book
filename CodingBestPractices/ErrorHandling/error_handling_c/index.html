<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <meta name="author" content="Geert Jan Bex">
  
  <link rel="shortcut icon" href="../../../img/favicon.ico">
  <title>Error handling in C - Defensive programming and debugging</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700" />

  <link rel="stylesheet" href="../../../css/theme.css" />
  <link rel="stylesheet" href="../../../css/theme_extra.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" />
  
  <script>
    // Current page data
    var mkdocs_page_name = "Error handling in C";
    var mkdocs_page_input_path = "CodingBestPractices/ErrorHandling/error_handling_c.md";
    var mkdocs_page_url = null;
  </script>
  
  <script src="../../../js/jquery-2.1.1.min.js" defer></script>
  <script src="../../../js/modernizr-2.8.3.min.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
        <a href="../../.." class="icon icon-home"> Defensive programming and debugging</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../..">Welcome to Defensive Programming and Debugging</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Preface</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../../Intro/economics_of_bugs/">Motivation</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../Intro/scope/">Scope</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../Intro/software/">Software environment</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Taxonomy of bugs</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../../Taxonomy/taxonomy_intro/">Introduction</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../Taxonomy/requirements_bugs/">Bugs in requirements</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../Taxonomy/structural_bugs/">Structural bugs</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../Taxonomy/arithmetic_bugs/">Arithmetic bugs</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../Taxonomy/data_races_deadlocks/">Data races & deadlocks</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../Taxonomy/data_bugs/">Bugs in data</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Writing good code</span></p>
                <ul class="current">
                    <li class="toctree-l1"><a class="reference internal" href="../../coding_best_practices_intro/">Introduction</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../coding_best_practices/">Coding style</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../error_handling_fortran/">Error handling in Fortran</a>
                    </li>
                    <li class="toctree-l1 current"><a class="reference internal current" href="./">Error handling in C</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#dynamic-memory-allocation">Dynamic memory allocation</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#string-conversion">String conversion</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#file-io">File I/O</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#overly-defensive-programming">Overly defensive programming</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#error-context">Error context</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#floating-point-expectations">Floating point expectations</a>
    </li>
    </ul>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../error_handling_cpp/">Exceptions in C++</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../assertions/">Assertions</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Documentation</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../../Documentation/documentation_intro/">Introduction</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../Documentation/documentation_best_practices/">Best practices</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../Documentation/mkdocs/">MkDocs for application documentation</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Unit testing</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../../Testing/UnitTesting/unit_testing_intro/">Introduction</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../Testing/UnitTesting/unit_testing_best_practices/">Best practices</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../Testing/UnitTesting/pfunit_fortran/">pfUnit for Fortran</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../Testing/UnitTesting/cunit_c/">CUnit for C</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../Testing/UnitTesting/catch2_cpp/">Catch2 for C++</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Functional testing</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../../Testing/FunctionalTesting/functional_testing_intro/">Introduction</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../Testing/FunctionalTesting/functional_testing_best_practices/">Best practices</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Code coverage</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../../Testing/CodeCoverage/code_coverage_intro/">Introduction</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../Testing/CodeCoverage/code_coverage_best_practices/">Best practices</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Code validation</span></p>
                <ul>
                    <li class="toctree-l1"><a class="" href="../../../CodeValidation/code_validation_intro.md">Introduction</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../CodeValidation/Compilers/gfortran_flags/">Flags for gfortran</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../CodeValidation/Compilers/ifort_flags/">Flags for ifort</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../CodeValidation/Compilers/gcc_flags/">Flags for gcc/g++</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../CodeValidation/Compilers/icc_flags/">Flags for icc/icpc</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../CodeValidation/StaticCodeAnalyzers/clang_tidy/">Clang Tidy</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Finding bugs at runtime</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../../BugsAtRuntime/finding_bugs_intro/">Introduction</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../BugsAtRuntime/finding_bugs_best_practices/">Best practices</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../BugsAtRuntime/heisenbugs/">Reproducibility & Heisenbugsi</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../BugsAtRuntime/parallel_debugging_best_practices/">Best practices for parallel applications</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../BugsAtRuntime/Debuggers/Gdb/gdb_features/">GDB Features</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../BugsAtRuntime/Debuggers/Gdb/gdb_attach/">Attaching GDB to running processes</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../BugsAtRuntime/Debuggers/Gdb/gdb_reverse_debugging/">Reverse debugging with GDB</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../BugsAtRuntime/Debuggers/Gdb/gdb_omp_debugging/">Debugging OpenMP applications with GDB</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../BugsAtRuntime/tracing/">Tracing applications</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../BugsAtRuntime/Debuggers/ArmDdt/arm_ddt/">Arm DDT parallel debugger</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../BugsAtRuntime/Verification/Compilers/gfortran_flags/">Compiler instrumentation for gfortran</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../BugsAtRuntime/Verification/Compilers/ifort_flags/">Compiler instrumentation for ifort</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../BugsAtRuntime/Verification/Compilers/gcc_sanitize/">Sanitizer instrumentation for C/C++</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../BugsAtRuntime/Verification/Compilers/icc_flags/">Compiler instrumentation for icc/icpc</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Appendices</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../../Appendices/rosetta_stone/">Rosetta stone</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../../Appendices/syntax_vs_semantics/">Syntax versus semantics</a>
                    </li>
                </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../..">Defensive programming and debugging</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../..">Docs</a> &raquo;</li>
    
      
        
          <li>Writing good code &raquo;</li>
        
      
    
    <li>Error handling in C</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="error-handling-in-c">Error handling in C</h1>
<p>Quite a number of bugs are introduced due to incorrect or even no handling of error conditions during the execution of an application.  This type of defect is especially annoying since the symptoms will occur some time after the actual cause, and manifest themselves in functions that seem to have little to do with that cause.  This "lack of locality" makes identifying the issue quite hard.</p>
<p>A defensive style of programming will help to prevent these situations.</p>
<p>Note that proper error handling can be quite complex and increase the size of your code base substantially.</p>
<h2 id="dynamic-memory-allocation">Dynamic memory allocation</h2>
<p>In C, a primary example of non-local issues is the management of dynamic memory, i.e., memory allocated on the heap using <code>malloc</code> or a related function.</p>
<p>Consider the following code:</p>
<pre><code class="c">#include &lt;stdlib.h&gt;

double *create_vector(unsigned long n) {
    return (double *) calloc(n, sizeof(double));
}
...
void daxpy(double alpha, double *x, double *y, unsigned long n) {
    for (unsigned long i = 0; i &lt; n; i++)
        x[i] = alpha*x[i] + y[i];
}
</code></pre>

<p>Allocation functions such as <code>calloc</code> will return a <code>NULL</code> value when there is not enough memory space to accommodate the request.  However, since <code>create_vector</code> doesn't check, the application will continue under the assumption that its result is indeed an array with all <code>n</code> elements set to zero.</p>
<p>At some point, e.g., in a call to the function <code>daxpy</code>, the <code>double</code> pointer <code>x</code>, or <code>y</code>, or both may in fact contain that <code>NULL</code>, and the application will crash with a segmentation fault. The problem, in this case merely a symptom, will occur in <code>daxpy</code>, while the cause is in fact in <code>create_vector</code>, or, to be more precise, wherever the size of the array was computed. If this is a complex application, it may take you a while to track down the root cause of this crash.</p>
<p>You want errors to occur as soon as possible since the closer that happens in space and time to the root cause, the easier it will be to identify and fix the issue.</p>
<p>In this particular case, the function <code>create_vector</code> should check whether <code>calloc</code> returns <code>NULL</code>, and if so, generate an error.</p>
<pre><code class="c">#include &lt;err.h&gt;
#include &lt;stdlib.h&gt;

#define MEM_ALLOC_ERR 11

double *create_vector(unsigned long n) {
    double *v = (double *) calloc(n, sizeof(double));
    if (v == NULL)
        errx(MEM_ALLOC_ERR, &quot;can't allocate vector of size %lu&quot;, n);
    return v;
}
</code></pre>

<p>The <code>errx</code> function declared in the <code>err.h</code> will print the error message to standard error and terminate the application with exit status <code>MEM_ALLOC_ERR</code>.  This makes it a lot easier to find the problem since you only need to figure out why the value of <code>n</code> is too large.</p>
<p>Seasoned C programmers will argue that the above code fragment is not idiomatic and should be written as:</p>
<pre><code class="c">double *create_vector(unsigned long n) {
    double *v;
    if (!(v = (double *) calloc(n, sizeof(double))))
        errx(MEM_ALLOC_ERR, &quot;can't allocate vector of size %lu&quot;, n);
    return v;
}
</code></pre>

<p>When this application is run and it fails, this will produce the following output:</p>
<pre><code>allocation_error.exe: can't allocate data of size 10000000000
</code></pre>

<p>Although this error message describes the issue, it could be more informative by using the values of a few macros:</p>
<ul>
<li><code>__FILE__</code> contains the name of the source file it occurs in,</li>
<li><code>__LINE__</code> contains the line number of the source file it occurs on,</li>
<li><code>__func__</code> contains the name of the current function (introduced in C99).</li>
</ul>
<pre><code class="c">double *create_vector(unsigned long n) {
    double *v;
    if (!(v = (double *) calloc(n, sizeof(double))))
        errx(MEM_ALLOC_ERR, &quot;%s:%d (%s) can't allocate vector of size %lu&quot;,
             __FILE__, __LINE__, __func__, n);
    return v;
}
</code></pre>

<p>Now the output would be:</p>
<p>~~~~bash
 allocation_error.exe: allocation_error.c:12 (create_vector): can't allocate data of size 10000000000
 ~~~~</p>
<p>The <code>__LINE__</code> macro is set to the line number it occurs on in the source file, so it will not actually be the line number on which the error occurs, but it points you in the  right direction anyway.</p>
<p>Although it is possible to print a backtrace of the current stack, that is probably not worth the effort since this can be handled more easily and conveniently using a debugger.</p>
<h2 id="string-conversion">String conversion</h2>
<p>Often, the functions <code>atoi</code>, <code>atol</code>, and <code>atof</code> are used to convert command line arguments to <code>int</code>, <code>long</code>, and <code>float</code>/<code>double</code> values respectively.  However, in general, this is not good practice.</p>
<p>When the <code>char</code> array passed to these functions can not be converted to the desired data type, the behaviour is undefined according to the C specification.  In other words, it is up to the implementer of the standard library to decide what happens in this case.</p>
<p>For instance, consider the following simple program:</p>
<pre><code class="c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(int argc, char *argv[]) {
    long n = 5;
    double a = 3.14;
    if (argc &gt; 1)
        n = atol(argv[1]);
    if (argc &gt; 2)
        a = atof(argv[2]);
    printf(&quot;n = %ld, a = %lf\n&quot;, n, a);
    return 0;
}
</code></pre>

<p>When you compile this with either GCC or Intel compilers and run it, you will get the following output:</p>
<pre><code class="bash">$ ./command_line_args.exe
n = 5, a = 3.140000

$ ./command_line_args.exe 15abc 1.43e-2def
n = 15, a = 0.014300

$ ./command_line_args.exe 12.73
n = 12, a = 3.140000

$ ./command_line_args.exe abc def
n = 0, a = 0.000000
</code></pre>

<p>When used as intended, the applications works as expected.  However, when the values passed via the command line are not appropriate, the application will run without warnings or errors, but it will most likely produce results you don't expect.</p>
<p>This is an argument to avoid <code>atoi</code> and its ilk, and to use functions that are more robust and check for problems.  The following code illustrates how to use <code>strtol</code> and <code>strtod</code>.</p>
<pre><code class="c">#include &lt;err.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(int argc, char *argv[]) {
    long n = 5;
    double a = 3.14;
    if (argc &gt; 1) {
        char *end_ptr = argv[1];
        n = strtol(argv[1], &amp;end_ptr, 10);
        if (*end_ptr != '\0' || end_ptr == argv[1])
            warnx(&quot;'%s' could not be (completely) converted to long&quot;,
                  argv[1]);
    }
    if (argc &gt; 2) {
        char *end_ptr = argv[2];
        a = strtod(argv[2], &amp;end_ptr);
        if (*end_ptr != '\0' || end_ptr == argv[2])
            warnx(&quot;'%s' could not be (completely) converted to double&quot;,
                  argv[2]);
    }
    printf(&quot;n = %ld, a = %lf\n&quot;, n, a);
    return 0;
}
</code></pre>

<p>This application will issue warnings if the command line arguments can not be converted properly.  The value of <code>end_ptr</code> is used to detect issues.  If  </p>
<ul>
<li><code>*end_ptr</code> != '\0', then the first part of the argument could be converted to a number, but subsequent characters could not, e.g., <code>15abc</code>;</li>
<li><code>end_prt == argv[1]</code>, then either the argument is an empty string or it completely consists of characters that can not be converted to a number.</li>
</ul>
<p>Of course, substituting <code>errx</code> for <code>warnx</code> would terminate the application rather than just print a warning message.  Which action is most appropriate depends on the application.  Just like <code>errx</code>, <code>warnx</code> is declared in <code>err.h</code>.</p>
<p>When you have to deal with non-trivial command line arguments such as options and flags, you should consider using the <code>getopt</code> function declared in <code>unistd.h</code> for that purpose.  This is however outside the scope of this course.  Alternatively, for C++, you could go with the Boost library's <code>program_options</code>.</p>
<h2 id="file-io">File I/O</h2>
<p>When reading or writing files quite a number of things can go wrong.</p>
<p>Just like the functions for memory allocation, the <code>fopen</code> function will return a null pointer when the operation fails.  If you don't check for that, your application will most likely crash with a segmentation fault as soon as it attempts to read or write.</p>
<p>The code fragment below will open a file, read it line by line, and output the length of each line, followed by the line itself.</p>
<pre><code class="c">#include &lt;err.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define ARG_ERR 1
#define FILE_OPEN_ERR 2

int main(int argc, char *argv[]) {
    if (argc == 1)
        errx(ARG_ERR, &quot;no file name specified&quot;);
    FILE *fp;
    char *line = NULL;
    size_t buffer_length;
    ssize_t nr_chars;
    if (!(fp = fopen(argv[1], &quot;r&quot;)))
        err(FILE_OPEN_ERR, &quot;can't open file '%s' for reading&quot;, argv[1]);
    while ((nr_chars = getline(&amp;line, &amp;buffer_length, fp)) != -1) {
        printf(&quot;%3zu: %s&quot;, nr_chars, line);
    }
    free(line);
    fclose(fp);
    return 0;
}
</code></pre>

<p>The application verifies that the file has been opened successfully, and if not, it uses the <code>err</code> function declared in <code>err.h</code> to report this and terminate the application.  The <code>err</code> function is quite similar to <code>errx</code>, but it will also print the error message associated with the failed system call. For instance, when called with a file that doesn't exist, you will get the following error message:</p>
<pre><code class="bash">$ ./file_error.exe bla
file_error.exe: can't open file 'bla' for reading: No such file or directory
</code></pre>

<p>On the other hand, if it is called with a file that exists, but that you don't have permission to read or write, you would get the following:</p>
<pre><code class="bash">$ ./file_error.exe test.txt
file_error.exe: can't open file 'test.txt' for reading: Permission denied
</code></pre>

<p>In this case, using <code>err</code> rather than <code>errx</code> improves the quality of the error message and helps the user of your application to figure out what the problem might be.</p>
<p>It is also quite useful to check the return value of functions like <code>scanf</code>. This will alert you to problems that may otherwise go unnoticed. Consider the following input file that is used to initialise the coordinates of 3D point:</p>
<pre><code>x = 1.1
y = 2.2
z = 3.3
</code></pre>

<p>The following application reads that configuration file and prints the coordinates of the point.</p>
<pre><code class="c">#include &lt;err.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#define ARG_ERR 1
#define FILE_OPEN_ERR 2
#define VALUE_ERR 3

typedef struct {
    double x, y, z;
} Point;

int main(int argc, char *argv[]) {
    if (argc == 1)
        errx(ARG_ERR, &quot;no file name specified&quot;);
    FILE *fp;
    char name[20];
    double value;
    Point point;
    if (!(fp = fopen(argv[1], &quot;r&quot;)))
        err(FILE_OPEN_ERR, &quot;can't open file '%s' for reading&quot;, argv[1]);
    while (fscanf(fp, &quot;%s = %lf&quot;, name, &amp;value) != -1) {
        if (!strcmp(&quot;x&quot;, name))
            point.x = value;
        else if (!strcmp(&quot;y&quot;, name))
            point.y = value;
        else if (!strcmp(&quot;z&quot;, name))
            point.z = value;
        else
            errx(VALUE_ERR, &quot;invalid name '%s'&quot;, name);
    }
    fclose(fp);
    printf(&quot;x = %lf, y = %lf, z = %lf\n&quot;, point.x, point.y, point.z);
    return 0;
}
</code></pre>

<p>Even with an incorrect input file such as the one below, this application will continue to run, most likely producing nonsense results.</p>
<pre><code>x = 1.1
y =
z = 3.3
</code></pre>

<p>The output would be the following, an unintended result is printed, and no errors are reported:</p>
<pre><code class="bash">$ ./read_error_incorrect.exe input_incomplete.txt
x = 1.100000, y = 1.100000, z = 3.300000
</code></pre>

<p>The following input would cause an error, although it is a fairly cryptic one:</p>
<pre><code>x = 1.1
y = O.5
z = 3.3
</code></pre>

<p>This would be the output:</p>
<pre><code class="bash">./read_error_incorrect.exe input_nok.txt
read_error_incorrect.exe: invalid name 'O.5'
</code></pre>

<p>Explicitly checking the number of values processed by <code>fscanf</code> will detect the problem and avoid some nasty issues later on.</p>
<pre><code class="c">#include &lt;err.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#define ARG_ERR 1
#define FILE_OPEN_ERR 2
#define VALUE_ERR 3

typedef struct {
    double x, y, z;
} Point;

int main(int argc, char *argv[]) {
    if (argc == 1)
        errx(ARG_ERR, &quot;no file name specified&quot;);
    FILE *fp;
    int nr_read;
    int line_nr = 0;
    char name[20];
    double value;
    Point point;
    if (!(fp = fopen(argv[1], &quot;r&quot;)))
        err(FILE_OPEN_ERR, &quot;can't open file '%s' for reading&quot;, argv[1]);
    while ((nr_read = fscanf(fp, &quot;%s = %lf&quot;, name, &amp;value)) != -1) {
        line_nr++;
        if (nr_read != 2)
            errx(VALUE_ERR, &quot;invalid input on line %d of %s\n&quot;,
                 line_nr, argv[1]);
        if (!strcmp(&quot;x&quot;, name))
            point.x = value;
        else if (!strcmp(&quot;y&quot;, name))
            point.y = value;
        else if (!strcmp(&quot;z&quot;, name))
            point.z = value;
        else
            errx(VALUE_ERR, &quot;invalid name '%s'&quot;, name);
    }
    fclose(fp);
    printf(&quot;x = %lf, y = %lf, z = %lf\n&quot;, point.x, point.y, point.z);
    return 0;
}
</code></pre>

<p>When the input is invalid, you get an error:</p>
<pre><code class="bash">$ ./read_error.exe input_nok.txt
read_error.exe: invalid input on line 2 of input_nok.txt
</code></pre>

<p>Note that keeping track of the line number in the input file and reporting it in case of an error will again help the user of this application to identify the problem.</p>
<h2 id="overly-defensive-programming">Overly defensive programming</h2>
<p>Grace Hopper is credited with the quote</p>
<blockquote>
<p>It's easier to ask forgiveness than it is to get permission.</p>
</blockquote>
<p>Before even attempting to open a file with a given name, you could check whether</p>
<ul>
<li>something with that name exists,</li>
<li>it is actually a file,</li>
<li>you have permission to open it.</li>
</ul>
<p>Doing those checks is like asking permission in an administrative matter.  It is a lengthy process, it is tedious and boring.  The alternative is to simply attempt to open the file, and if that fails, simply tell the user why.</p>
<p>Thanks to functions such as <code>err</code> and <code>warn</code> that will pick up the message associated with the most recent error, chances are that your application will write error messages that are as informative as the ones you'd handcraft by checking for all conceivable error conditions manually.  Your code will be more concise, simpler, and hence the probability of having bugs in your error handling code is reduced.</p>
<h2 id="error-context">Error context</h2>
<p>At which level do you report an error?  This is a non-trivial question.</p>
<p>Suppose you are developing an application that reads some parameters from a configuration file, it creates data structures, initialises them, and starts to compute. One of the configuration parameters is the size of the vectors your computation uses, and those are dynamically allocated.</p>
<p>Now you already know that your should check the result of <code>malloc</code> to ensure that the allocation succeeded.  Failing to do so will most likely result in a segmentation fault.</p>
<p>However, the user of your application (potentially you) enters a vector size in the configuration file that is too large to be allocated.  No problem though, your application handles error conditions and reports to the user.</p>
<p>You could report the error and terminate execution in the function where it actually occurs, the <code>create_vector</code> function you defined in one of the previous sections.  This would inform the user that some data structure can not be allocated.  However, unless she is familiar with the nuts and bolts of the application, that may in fact be completely uninformative.  The function <code>create_vector</code> has no clue about the context in which it is called, and can hardly be expected to produce a more meaningful error message.</p>
<p>It would be more useful to the user if this error were reported to the calling function, which has more contextual information, and that this function would report an error that has better semantics.  At the end of the day, the relevant information is that you should reduce the value of a parameter in your configuration file.</p>
<p>Handling errors in the appropriate context is not that easy.  It requires careful planning and formulating error messages from the perspective of the user at each layer in your application.  In a language such as C, this means that functions should return status information.  In the C API for the MPI library for instance, almost all functions return an <code>int</code> exit value that can be used to check whether the function call was executed successfully.</p>
<p>In programming languages such as C++ and Python, error handling is simpler since you can use exceptions to propagate status information when a problem occurs and handle it using <code>try ... catch ...</code> statements in C++ or <code>try: ... except ...: ...</code> in Python.</p>
<p>Regardless of the programming language you use, proper error handling will be fairly complex.</p>
<h2 id="floating-point-expectations">Floating point expectations</h2>
<p>There is a number of problems that may arise during numerical computations and that go unnoticed or are only noticed late, i.e., when a lot of expensive computations have been performed.</p>
<p>The IEEE standard 754 defines five exceptions that can occur as a result of floating point operations:</p>
<ol>
<li>inexact: accuracy is lost;</li>
<li>divide by zero;</li>
<li>underflow: a value can not be represented and is round to zero;</li>
<li>overflow: a value is too large to be represented; and</li>
<li>invalid: operations is invalid for the given operands.</li>
</ol>
<p>A divide by zero and an overflow will result in positive or negative infinity, depending on the sign of the operand, while an invalid operation will result in positive or negative NaN (Not a Number).  These values will propagate throughout your computations rendering them useless.</p>
<p>Note that an underflow will easily go unnoticed, which makes it even more dangerous.</p>
<p>The ISO C99 standard defines a number of constants and functions to detect IEEE floating point exceptions, primarily:</p>
<ul>
<li><code>fetestexcept</code> to test whether an floating point exception occurred, and</li>
<li><code>feclearexcept</code> to reset the exception bits.</li>
</ul>
<p>You can test for the five exceptions using the following predefined constants:</p>
<ul>
<li><code>FE_INEXACT</code>,</li>
<li><code>FE_DIVBYZERO</code>,</li>
<li><code>FE_UNDERFLOW</code>,</li>
<li><code>FE_OVERFLOW</code>,</li>
<li><code>FE_INVALID</code>, or</li>
<li>for all using <code>FE_ALL_EXCEPT</code>.</li>
</ul>
<p>Below is a code sample that shows how to detect invalid and/or overflow in a computation.  The relevant declarations are in the header file <code>fenv.h</code>.</p>
<pre><code class="c">#include &lt;err.h&gt;
#include &lt;fenv.h&gt;
#include &lt;math.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

double sum(int n);

int main(int argc, char *argv[]) {
    int status;
    int n = 10;
    if (argc == 2)
        n = atoi(argv[1]);
    double result = sum(n);
    if ((status = fetestexcept(FE_INVALID | FE_OVERFLOW))) {
        if (status &amp; FE_INVALID)
            warnx(&quot;invalid operation detected&quot;);
        else if (status &amp; FE_OVERFLOW)
            warnx(&quot;overflow detected&quot;);
    }
    printf(&quot;sum = %le\n&quot;, result);
    return 0;
}
</code></pre>

<p>This application would trap any IEEE floating point overflow or invalid exceptions that are raised in the function <code>sum</code>.</p>
<p>Alternatively, functions in <code>math.h</code> can be used to check whether a value is normal, e.g.,</p>
<pre><code class="c">#include &lt;err.h&gt;
#include &lt;math.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

double sum(int n);

int main(int argc, char *argv[]) {
    int status;
    int n = 10;
    if (argc == 2)
        n = atoi(argv[1]);
    double result = sum(n);
    if (!isnormal(result))
        warnx(&quot;non-normal result detected&quot;);
    printf(&quot;sum = %le\n&quot;, result);
    return 0;
}
</code></pre>

<p>The <code>math.h</code> header defines a number of other functions that may be useful in this context, e.g.,</p>
<ul>
<li><code>isinf</code>,</li>
<li><code>isfinite</code>,</li>
<li><code>isnan</code>.</li>
</ul>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../error_handling_cpp/" class="btn btn-neutral float-right" title="Exceptions in C++">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../error_handling_fortran/" class="btn btn-neutral" title="Error handling in Fortran"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
        <span><a href="../error_handling_fortran/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../error_handling_cpp/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>
    <script>var base_url = '../../..';</script>
    <script src="../../../js/theme.js" defer></script>
      <script src="../../../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
