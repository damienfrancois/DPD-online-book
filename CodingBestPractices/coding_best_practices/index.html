<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <meta name="author" content="Geert Jan Bex">
  
  <link rel="shortcut icon" href="../../img/favicon.ico">
  <title>Coding style - Defensive programming and debugging</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700" />

  <link rel="stylesheet" href="../../css/theme.css" />
  <link rel="stylesheet" href="../../css/theme_extra.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" />
  
  <script>
    // Current page data
    var mkdocs_page_name = "Coding style";
    var mkdocs_page_input_path = "CodingBestPractices/coding_best_practices.md";
    var mkdocs_page_url = null;
  </script>
  
  <script src="../../js/jquery-2.1.1.min.js" defer></script>
  <script src="../../js/modernizr-2.8.3.min.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
        <a href="../.." class="icon icon-home"> Defensive programming and debugging</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../..">Welcome to Defensive Programming and Debugging</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Preface</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../Intro/economics_of_bugs/">Motivation</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../Intro/scope/">Scope</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../Intro/software/">Software environment</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Taxonomy of bugs</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../Taxonomy/taxonomy_intro/">Introduction</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../Taxonomy/requirements_bugs/">Bugs in requirements</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../Taxonomy/structural_bugs/">Structural bugs</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../Taxonomy/arithmetic_bugs/">Arithmetic bugs</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../Taxonomy/data_races_deadlocks/">Data races & deadlocks</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../Taxonomy/data_bugs/">Bugs in data</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Writing good code</span></p>
                <ul class="current">
                    <li class="toctree-l1"><a class="reference internal" href="../coding_best_practices_intro/">Introduction</a>
                    </li>
                    <li class="toctree-l1 current"><a class="reference internal current" href="./">Coding style</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#format-your-code-nicely">Format your code nicely</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#use-language-idioms">Use language idioms</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#choose-descriptive-names">Choose descriptive names</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#keep-it-simple">Keep it simple</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#limit-scope">Limit scope</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#be-explicit-about-constants">Be explicit about constants</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#control-access">Control access</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#variable-initialisation">Variable initialisation</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#to-comment-or-not-to-comment">To comment or not to comment?</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#stick-to-the-standard">Stick to the standard</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#copypaste-is-evil">Copy/paste is evil</a>
    </li>
    </ul>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../ErrorHandling/error_handling_fortran/">Error handling in Fortran</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../ErrorHandling/error_handling_c/">Error handling in C</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../ErrorHandling/error_handling_cpp/">Exceptions in C++</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../ErrorHandling/assertions/">Assertions</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Documentation</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../Documentation/documentation_intro/">Introduction</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../Documentation/documentation_best_practices/">Best practices</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../Documentation/mkdocs/">MkDocs for application documentation</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Unit testing</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../Testing/UnitTesting/unit_testing_intro/">Introduction</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../Testing/UnitTesting/unit_testing_best_practices/">Best practices</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../Testing/UnitTesting/pfunit_fortran/">pfUnit for Fortran</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../Testing/UnitTesting/cunit_c/">CUnit for C</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../Testing/UnitTesting/catch2_cpp/">Catch2 for C++</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Functional testing</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../Testing/FunctionalTesting/functional_testing_intro/">Introduction</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../Testing/FunctionalTesting/functional_testing_best_practices/">Best practices</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Code coverage</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../Testing/CodeCoverage/code_coverage_intro/">Introduction</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../Testing/CodeCoverage/code_coverage_best_practices/">Best practices</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Code validation</span></p>
                <ul>
                    <li class="toctree-l1"><a class="" href="../../CodeValidation/code_validation_intro.md">Introduction</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../CodeValidation/Compilers/gfortran_flags/">Flags for gfortran</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../CodeValidation/Compilers/ifort_flags/">Flags for ifort</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../CodeValidation/Compilers/gcc_flags/">Flags for gcc/g++</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../CodeValidation/Compilers/icc_flags/">Flags for icc/icpc</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../CodeValidation/StaticCodeAnalyzers/clang_tidy/">Clang Tidy</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Finding bugs at runtime</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../BugsAtRuntime/finding_bugs_intro/">Introduction</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../BugsAtRuntime/finding_bugs_best_practices/">Best practices</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../BugsAtRuntime/heisenbugs/">Reproducibility & Heisenbugsi</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../BugsAtRuntime/parallel_debugging_best_practices/">Best practices for parallel applications</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../BugsAtRuntime/Debuggers/Gdb/gdb_features/">GDB Features</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../BugsAtRuntime/Debuggers/Gdb/gdb_attach/">Attaching GDB to running processes</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../BugsAtRuntime/Debuggers/Gdb/gdb_reverse_debugging/">Reverse debugging with GDB</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../BugsAtRuntime/Debuggers/Gdb/gdb_omp_debugging/">Debugging OpenMP applications with GDB</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../BugsAtRuntime/tracing/">Tracing applications</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../BugsAtRuntime/Debuggers/ArmDdt/arm_ddt/">Arm DDT parallel debugger</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../BugsAtRuntime/Verification/Compilers/gfortran_flags/">Compiler instrumentation for gfortran</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../BugsAtRuntime/Verification/Compilers/ifort_flags/">Compiler instrumentation for ifort</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../BugsAtRuntime/Verification/Compilers/gcc_sanitize/">Sanitizer instrumentation for C/C++</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../BugsAtRuntime/Verification/Compilers/icc_flags/">Compiler instrumentation for icc/icpc</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">Appendices</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../Appendices/rosetta_stone/">Rosetta stone</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../Appendices/syntax_vs_semantics/">Syntax versus semantics</a>
                    </li>
                </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../..">Defensive programming and debugging</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../..">Docs</a> &raquo;</li>
    
      
        
          <li>Writing good code &raquo;</li>
        
      
    
    <li>Coding style</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="coding-best-practices-reading-material">Coding best practices: reading material</h1>
<p>A number of very simple things go a long way towards improving your code substantially. For good programmers, they are second nature, and you should strive to make them a habit.</p>
<p>In this section, we will use the term function in a very broad sense, simply to keep the text easy to read. In the context of Fortran, a function refers to a program unit, any procedure, either a function or a subroutine. It also refers to a method defined in a class. In the context of C++, we will use the term function for methods as well.</p>
<p>Similarly, we use the term variable for constants, and also for attributes of objects and classes, whenever that doesn't lead to confusion.</p>
<h2 id="format-your-code-nicely">Format your code nicely</h2>
<p>To quote Robert C. Martin, "Code formatting is about communication, and communication is the professional developer’s first order of business".</p>
<p>All programming languages have one or possibly multiple conventions about how to format source code. For example, consistent indentation of code helps considerably to assess the structure of a function at a glance. For multi-level indentation, always use the same width, e.g., multiples of four spaces.</p>
<p>The convention you have to use is often determined by the community you are working with, like your co-workers.  It is best to stick to that convention, since coding is communicating. If no convention is established, consider introducing one.  The one which is prevalent in the programming language community is most likely to be your best choice.</p>
<p>Whichever convention you follow, be consistent!</p>
<h2 id="use-language-idioms">Use language idioms</h2>
<p>Linguists use the term "idiom" for an expression that is very specific to a certain language and that cannot be translated literally to another. For instance, the English idiom "it is raining cats and dogs" would translate to "il pleut des cordes" in French.  The corresponding idiom in French is completely unrelated to its counterpart in English. Mastering idioms is one of the requirements for C1 certification, i.e., to be considered to have a proficiency close to that of native speakers.</p>
<p>We observe a similar phenomenon for programming languages. Some syntactic constructs are typical for a specific programming language but, when translated one-to-one into another language, lead to code constructs that are unfamiliar to programmers who are proficient in that language.  The code fragments below illustrate this for Fortran and C.</p>
<p>Although you could write line 4 of the C function below in this way, you most likely wouldn't since it is not idiomatic C.</p>
<pre><code class="c">int factorial(int n) {
    fac = 1;
    for (int i = 2; i &lt;= n; i++)
        fac = fac*i;
    return fac;
}
</code></pre>

<p>The idiomatic formulation of line 4 would be <code>fac *= i</code>.</p>
<p>In Fortran for example, you would write</p>
<pre><code class="fortran">REAL, DIMENSION(10) :: a
...
a = value
</code></pre>

<p>rather than</p>
<pre><code class="fortran">INTEGER :: i
REAL, DIMENSION(10) :: a
...
DO i = 1, 10
    a(i) = value
END DO
</code></pre>

<p>Using idioms, i.e., expressions that are particular to a (programming) language, will make your code much easier to interpret correctly by programmers that are fluent in that language.</p>
<h2 id="choose-descriptive-names">Choose descriptive names</h2>
<p>In a way, programming is storytelling. The data are the protagonist in the story, and the functions are the actions they take, or what happens to them. Hence variable names should be nouns and functions names should be verbs. If a function returns a property, it should be phrased as a question.</p>
<p>Any editor worth its salt provides completion, so you can't argue in favour of short but less descriptive names to save typing. A long but descriptive name is just a tab character away.</p>
<p>Choosing descriptive names for variables and functions is another aspect that can make reading your code much easier. Consider the following pseudo-code fragment, and although I'll grant that it is something of a caricature, I've seen some in the wild that are not significantly better.</p>
<pre><code>f = open(fn, 'r')
for i in f:
    x = get(i)
    if condition(x):
        a = compute(x)
        if a &lt; 3.14:
            do_something(a)
f.close()
</code></pre>

<p>A key principle of good software design is that of the least surprise. Choosing appropriate names for our variables and functions helps a lot in this respect.</p>
<h2 id="keep-it-simple">Keep it <em>simple</em></h2>
<p>Ideally, code is simple.  A function should have two levels of indentation at most.  This is advice you'll find in the literature on general purpose programming. Although this is good advice, there are some caveats in the context of scientific computing.</p>
<p>However, the gist is clear: code is as simple as possible, but not simpler.</p>
<p>Even for scientific code, a function has no more lines of code than fit comfortably on your screen. It is all too easy to lose track of the semantics if you can't get an overview of the code. Remember, not everyone has the budget for a 5K monitor.</p>
<p>If you find yourself writing a very long code fragment, ask yourself whether that is atomic, or whether the task it represents can be broken up into sub-tasks. If so, and that is very likely, introduce new functions for those sub-tasks with descriptive names. This will make the narrative all the easier to understand.</p>
<p>A function should have a single purpose, i.e., you should design it to do one thing, and one thing only.</p>
<p>For function signatures, simplicity matters as well.  Functions that take many arguments may lead to confusion.  In C and C++, you have to remember the order of the function arguments.  Accidentally swapping argument values with the same type in a function call can lead to interesting debugging sessions.</p>
<p>The same advice applies to Fortran procedures, keep the number of arguments limited.  However, Fortran supports using keyword arguments, a nice feature that makes your code more robust.  Consider the following procedure signature:</p>
<pre><code class="fortran">real function random_gaussian(mu, sigma)
    implicit none
    real, intent(in) :: mu, sigma
    ...
end function random_gaussian
</code></pre>

<p>You would have to check the documentation to know the order of the function arguments.  Consider the following four function calls:</p>
<ol>
<li><code>random_gaussian(0.0, 1.0)</code>: okay;</li>
<li><code>random_gaussian(1.0, 0.0)</code>: not okay;</li>
<li><code>random_gaussian(mu=0.0, sigma=1.0)</code>: okay;</li>
<li><code>random_gaussian(sigma=1.0, mu=0.0)</code>: okay.</li>
</ol>
<p>The two last versions of this call are easier to understand, since the meaning of the numbers is clear.  Moreover, since you can use any order, it eliminates a source of bugs.</p>
<p>Unfortunately, neither C nor C++ support this feature.</p>
<h2 id="limit-scope">Limit scope</h2>
<p>Many programmers will declare all variables at the start of a block, or even at the start of a function's implementation. This is a syntax requirement in C89 and Fortran.  However, C99 and C++ allow you to declare variables anywhere before their first use. Since the scope of a variable starts from its declaration, and extends throughout the block, that means it is in fact too wide.</p>
<p>Limiting the scope of declarations to a minimum reduces the probability of inadvertently using the variable, but it also improves code quality: the declaration of the variable is at the same location where the variable is first used, so the narrative is easier to follow.</p>
<p>In C++ this may even have performance benefits since a declaration may trigger a call to a potentially expensive constructor.</p>
<p>Fortran requires that variables are declared at the start of a compilation unit, i.e., <code>PROGRAM</code>, <code>FUNCTION</code>, <code>SUBROUTINE</code>, <code>MODULE</code>, but Fortran 2008 introduced the <code>BLOCK</code> statement in which local variables can be declared. Their scope doesn't extend beyond the <code>BLOCK</code>. Modern compilers support this Fortran 2008 feature.</p>
<p>Note that Fortran still allows variables to be implicitly typed, i.e., if you don't declare a variable explicitly, its type will be <code>INTEGER</code> if its starts with the characters <code>i</code> to <code>n</code>, otherwise its type will be <code>REAL</code>.</p>
<p>Consider the code fragment below. Since the variables were not declared explicitly, <code>i</code> is interpreted as <code>INTEGER</code> and <code>total</code> as <code>REAL</code>. However, the misspelled <code>totl</code> is also implicitly typed as <code>REAL</code>, initialised to <code>0.0</code>, and hence the value of <code>total</code> will be <code>10.0</code> when the iterations ends, rather than <code>100.0</code> as was intended.</p>
<pre><code class="fortran">INTEGER :: i
REAL :: total
DO i = 1, 10
    total = totl + 10.0
END DO
</code></pre>

<p>To avoid these problems caused by simple typos, use the <code>IMPLICIT NONE</code> statement before variable declarations in <code>PROGRAM</code>, <code>MODULE</code>, <code>FUNCTION</code>, <code>SUBROUTINE</code>, and <code>BLOCK</code>, e.g,</p>
<pre><code class="fortran">IMPLICIT NONE
INTEGER :: i
REAL :: total
DO i = 1, 10
    total = totl + 10.0
END DO
</code></pre>

<p>The compiler would give an error for the code fragment above since all variables have to be declared explicitly, and <code>totl</code> was not.</p>
<p>Limiting scope of of declarations extends to headers files that are included in C/C++.  It is recommended not to include files that are not required.  Not only will it pollute the namespace with clutter, but it will also increase build times.</p>
<p>In C++, you can importing everything defined in a namespace, e.g.,</p>
<pre><code class="c">using namespace std;
</code></pre>

<p>Although it saves on typing, it is better to either use the namespace prefix explicitly, or use only what is required, e.g.,</p>
<pre><code class="c">using std::cout;
using std::endl;
</code></pre>

<p>In Fortran it is also possible to restrict what to use from modules, e.g.,</p>
<pre><code class="fortran">use, intrinsic :: iso_fortran_env, only : REAL64, INT32
</code></pre>

<p>The <code>only</code> keyword ensures that only the parameters <code>REAL64</code> and <code>INT32</code> are imported from the <code>iso_fortran_env</code> module.</p>
<p>Note that the <code>intrinsic</code> keyword is used to ensure that the compiler supplied module is used, and not a module with the same name defined by you.</p>
<p>When developing multi-threaded C/C++ programs using OpenMP, limiting the scope of variables to parallel regions makes those variables thread-private, hence reducing the risk of data races. We will discuss this in more detail in a later section.  Unfortunately, the semantics for the Fortran <code>block</code> statement in an OpenMP do loop is not defined, at least up to the OpenMP 4.5 specification.  Although <code>gfortran</code> accepts such code constructs, and seems to generate code with the expected behavior, it should be avoided since Intel Fortran compiler will report an error for such code.</p>
<p>This recommendation is <a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-scope">mentioned</a> in the C++ core guidelines.</p>
<h2 id="be-explicit-about-constants">Be explicit about constants</h2>
<p>If a variable's value is not supposed to change during the run time of a program, declare it as a constant, so that the compiler will warn you if you inadvertently modify its value. In C/C++, use the <code>const</code> qualifier, in Fortran, use <code>PARAMETER</code>.</p>
<p>If arguments passed to function should be read-only, use <code>const</code> in C/C++ code, and <code>INTENT(IN)</code> in Fortran. Although Fortran doesn't require that you state the intent of arguments passed to procedures, it is nevertheless wise to do so. The compiler will catch at least some programming mistakes if you do.</p>
<p>However, this is not quite watertight, in fact, one can still change the value of a variable that is declared as a constant in C.  Compile and run the following program, and see what happens.</p>
<pre><code class="c">#include &lt;stdio.h&gt;

void do_mischief(int *n) {
    *n = 42;
}

int main(void) {
    const int n = 5;
    printf(&quot;originally, n = %d\n&quot;, n);
    do_mischief((int *) &amp;n);
    printf(&quot;mischief accomplished, n = %d\n&quot;, n);
    return 0;
}
</code></pre>

<p>In fact, this is <a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-casts-const">explicitly mentioned</a> in the C++ core guidelines.</p>
<h2 id="control-access">Control access</h2>
<p>When defining classes in C++ and Fortran, some attention should be paid to accessibility of object attributes. An object's state is determined by its attributes' values, so allowing unrestricted access to these attributes may leave the object in an inconsistent state.</p>
<p>In C++, object attributes and methods are private by default, while structure fields and methods are public.  For Fortran, fields in user defined types and procedures defined in modules are public by default. Regardless of the defaults, it is useful to specify the access restrictions explicitly. It is good practice to specify private access as the default, and public as the exception to that rule.</p>
<p>Interestingly, both Fortran and C++ have the keyword <code>protected</code>, albeit with very different semantics.  In Fortran, <code>protected</code> means that a variable defined in a module can be read by the compilation unit that uses it, but not modified.  In the module where it is defined, it can be modified though.  In C++, an attribute or a method that is declared <code>protected</code> can be accessed from derived classes as well as the class that defines it.  However, like attributes and methods declared <code>private</code>, it can not be accessed elsewhere.</p>
<p>This is another example where getting confused about the semantics can lead to interesting bugs.</p>
<p>In summary:</p>
<table>
<thead>
<tr>
<th>access modifier</th>
<th>C++</th>
<th>Fortran</th>
</tr>
</thead>
<tbody>
<tr>
<td>private</td>
<td>access restricted to class/struct</td>
<td>access restricted to module</td>
</tr>
<tr>
<td>protected</td>
<td>access restricted to class/struct and derived</td>
<td>variables: modify access restricted to module, read everywhere</td>
</tr>
<tr>
<td>public</td>
<td>attributes and methods can be accessed from everywhere</td>
<td>variables, types and procedures can be accessed from everywhere</td>
</tr>
<tr>
<td>none</td>
<td>class: private, struct: public</td>
<td>public</td>
</tr>
</tbody>
</table>
<h2 id="variable-initialisation">Variable initialisation</h2>
<p>The specifications for Fortran, C and C++ do not define the value an uninitialized variable will have. So you should always initialise variables explicitly, otherwise your code will have undefined, and potentially non-deterministic behavior. When you forget to initialise a variable, the compilers will typically let you get away with it. However, most compilers have optional flags that catch expressions involving uninitialised variables. We will discuss these and other compiler flags in a later section.</p>
<p>When initialising or, more generally, assigning a value to a variable that involves constants, your code will be easier to understand when those values indicate the intended type. For example, using <code>1.0</code> rather than <code>1</code> for floating point is more explicit. This may also avoid needless conversions. This also prevents arithmetic bugs since <code>1/2</code> will evaluate to <code>0</code> in C, C++ as well as Fortran.  Perhaps even more subtly, <code>1.25 + 1/2</code> will also evaluate to <code>1.25</code>, since the division will be computed using integer values, evaluating to <code>0</code>, which is subsequently converted to the floating point value <code>0.0</code>, and added to <code>1.25</code>.</p>
<p>Specifically for C++, I'd strongly encourage you to use list initialisation, since narrowing conversion would lead to warnings.  In the code fragment below, the first local variable <code>n1</code> will be initialised to <code>7</code> without any warnings, while the compiler will generate a warning for the initialisation of <code>n2</code>.</p>
<pre><code class="c++">int conversion(double x) {
    int n1 = x;
    int n2 {x};
    return n1 + n2;
}
</code></pre>

<h2 id="to-comment-or-not-to-comment">To comment or not to comment?</h2>
<p>Comments should never be a substitute for code that is easy to understand. In almost all circumstances, if your code requires a comment without which it can not be understood, it can be rewritten to be more clear.</p>
<p>Obviously, there are exceptions to this rule. Sometimes we have no alternative but to sacrifice a clean coding style for performance, or we have to add an obscure line of code to prevent a problem caused by over-eager compilers.</p>
<p>If you need to add a comment, remember that it should be kept up-to-date with the code. All too often, we come across comments that are no longer accurate because the code has evolved, but the corresponding comment didn't. In such situations, the comment is harmful, since it can confuse us about the intentions of the developer, and at the least, it will cost us time to disambiguate.</p>
<p>The best strategy is to make sure that the code tells its own story, and requires no comments.</p>
<p>A common abuse of comments is to disable code fragments that are no longer required, but that you still want to preserve. This is bad practice. Such comments make reading the code more difficult, and take up valuable screen real estate.
Moreover, when you use a version control system such as git or subversion in your development process, you can delete with impunity, in the sure knowledge that you can easily retrieve previous versions of your files. If you don't use a version control system routinely, you really should. See the additional material section for some pointers to information and  tutorials.</p>
<h2 id="stick-to-the-standard">Stick to the standard</h2>
<p>The official syntax and semantics of languages like C, C++ and Fortran is defined in official specifications. All compilers that claim compliance with these standards have to implement these specifications.</p>
<p>However, over the years, compiler developers have added extensions to the specifications. The Intel Fortran compiler for instance has a very long history that can trace its ancestry back to the DEC compiler, and implements quite a number of Fortran extensions. Similarly, the GCC C++ compiler supports some non-standard features.</p>
<p>It goes without saying that your code should not rely on such compiler specific extensions, even if that compiler is mainstream and widely available. There is no guarantee that future releases of that same compiler will still support the extension, and the only official information about that extension would be available in the compiler documentation, not always the most convenient source.</p>
<p>Moreover, that implies that even if your code compiles with a specific compiler, that doesn't mean it complies with the official language specification. An other compiler would simply generate error message for the same code, and would fail to compile it.</p>
<p>Using language extensions makes code harder to read. As a proficient programmer, you're still not necessarily familiar with language extensions, so you may interpret those constructs incorrectly.</p>
<p>Hence I'd encourage you strongly to strictly adhere to a specific language specification.  For C there are three specifications that are still relevant, C89, C99 and C11.  For C++ that would be C++11, C++14 and C++17.  The relevant specification for Fortran are those of 2003 and 2008. References to those specifications can be found in the section on additional material.</p>
<p>For C, you may be interested to read the MISRA C software development guidelines, a collections of directives and rules specified by the Motor Industry Software Reliability Association (MISRA) aimed at ensuring safer and more reliable software systems in the automotive industry.  A reference to this specification is mentioned in the additional material section.</p>
<h2 id="copypaste-is-evil">Copy/paste is evil</h2>
<p>If you find yourself copying and pasting a fragment of code from one file location to another, or from one file to another, you should consider turning it into a function.  Apart from making your code easier to understand, it makes it also easier to maintain.</p>
<p>Suppose there is a bug in the fragment.  If you copy/pasted it, you would have to remember to fix the bug in each instance of that code fragment.  If it was encapsulated in a function, you would have to fix the problem in a single spot only.</p>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../ErrorHandling/error_handling_fortran/" class="btn btn-neutral float-right" title="Error handling in Fortran">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../coding_best_practices_intro/" class="btn btn-neutral" title="Introduction"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
        <span><a href="../coding_best_practices_intro/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../ErrorHandling/error_handling_fortran/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>
    <script>var base_url = '../..';</script>
    <script src="../../js/theme.js" defer></script>
      <script src="../../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
